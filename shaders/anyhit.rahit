#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

layout(location = 0) rayPayloadInEXT vec4 payload;
hitAttributeEXT vec3 attribs;

layout(location = 0) in vec3 inBaseColor;
layout(location = 1) in float inValue;
layout(location = 2) in float inDimension;
layout(location = 3) in float inWavePhase;
layout(location = 4) in float inCycleProgress;
layout(location = 5) in float inDarkMatterPulse;
layout(location = 6) in float inDarkEnergyGlow;

layout(set = 0, binding = 3, scalar) readonly buffer TransparencyBuffer {
    float transparencies[];
} transparencyBuffer;

const float PI = 3.1415926535;
const float INV_MAX_DIM = 1.0 / 9.0;
const float OMEGA = 2.0 * PI / (2.0 * 9.0 - 1.0);

// Simple noise for stochastic alpha
float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
float noise(vec2 uv) {
    vec2 i = floor(uv);
    vec2 f = fract(uv);
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),
        mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x),
        u.y
    );
}

// Reused dimensional functions
float computeDarkMatterDensity(float dim) {
    float density = inDarkMatterPulse * (1.0 + dim * INV_MAX_DIM);
    if (dim > 3.0) {
        density *= (1.0 + 0.2 * (dim - 3.0));
    }
    return max(1e-15, density);
}

float computeDarkEnergy(float distance) {
    return inDarkEnergyGlow * exp(distance * INV_MAX_DIM);
}

float computeCollapse(float dim) {
    if (dim < 1.5) return 0.0;
    float phase = dim / (2.0 * 9.0);
    return inValue * dim * exp(-0.2 * (dim - 1.0)) * abs(cos(2.0 * PI * phase));
}

void main() {
    // Initialize variables
    float dim = max(1.0, inDimension);
    float phase = inWavePhase + inCycleProgress * PI * 2.0;
    vec3 worldPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;

    // Get material transparency
    uint instanceId = gl_InstanceID;
    float transparency = transparencyBuffer.transparencies[nonuniformEXT(instanceId)];
    
    // Dimensional effects
    float collapse = computeCollapse(dim);
    float distance = abs(dim - floor(dim + 0.5));
    float darkEnergy = computeDarkEnergy(distance) * (1.0 + 0.2 * cos(phase * OMEGA));

    // Dynamic alpha
    float alpha = clamp(transparency * (0.8 + 0.2 * (darkEnergy + collapse)), 0.1, 0.9);
    
    // Stochastic alpha testing
    float n = noise(worldPos.xy * (1.0 + 0.5 * inDarkEnergyGlow));
    if (n > alpha) {
        ignoreIntersectionEXT;
    }
    // Implicitly accept intersection if noise <= alpha (no acceptIntersectionEXT needed)
}