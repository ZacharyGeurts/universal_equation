#version 450
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Input structure for DimensionInteraction
struct DimensionInteraction {
    int dimension;
    float distance;
    float darkMatterDensity;
};

// Input buffer for interactions
layout(std430, binding = 0) buffer Interactions {
    DimensionInteraction interactions[];
};

// Output buffer for EnergyResult
layout(std430, binding = 1) buffer Output {
    vec4 results[]; // observable, potential, darkMatter, darkEnergy
};

// Uniforms for parameters
uniform int maxDimensions;
uniform int currentDimension;
uniform int mode;
uniform float influence;
uniform float weak;
uniform float collapse;
uniform float twoD;
uniform float threeDInfluence;
uniform float oneDPermeation;
uniform float darkMatterStrength;
uniform float darkEnergyStrength;
uniform float alpha;
uniform float beta;
uniform float omega;
uniform float invMaxDim;

// Constants
const float PI = 3.14159265359;

// Compute interaction for a given dimension and distance
float computeInteraction(int dimension, float distance) {
    float denom = max(1e-15, pow(float(currentDimension), float(dimension)));
    float modifier = (currentDimension > 3 && dimension > 3) ? weak : 1.0;
    if (currentDimension == 3 && (dimension == 2 || dimension == 4)) {
        modifier *= threeDInfluence;
    }
    return influence * (distance / denom) * modifier;
}

// Compute permeation factor
float computePermeation(int dimension) {
    if (dimension == 1 || currentDimension == 1) return oneDPermeation;
    if (currentDimension == 2 && dimension > 2) return twoD;
    if (currentDimension == 3 && (dimension == 2 || dimension == 4)) return threeDInfluence;
    return 1.0;
}

// Compute collapse term
float computeCollapse() {
    if (currentDimension == 1) return 0.0;
    float phase = float(currentDimension) / (2.0 * float(maxDimensions));
    return collapse * float(currentDimension) * exp(-beta * float(currentDimension - 1)) *
           abs(cos(2.0 * PI * phase));
}

// Compute dark energy
float computeDarkEnergy(float distance) {
    return darkEnergyStrength * exp(distance * invMaxDim);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // Initialize result components
    float totalInfluence = influence;
    if (currentDimension >= 2) {
        totalInfluence += twoD * cos(omega * float(currentDimension));
    }
    if (currentDimension == 3) {
        totalInfluence += threeDInfluence;
    }

    float totalDarkMatter = 0.0;
    float totalDarkEnergy = 0.0;
    float interactionSum = 0.0;

    // Iterate over interactions
    for (int i = 0; i < interactions.length(); ++i) {
        DimensionInteraction interaction = interactions[i];
        float influence = computeInteraction(interaction.dimension, interaction.distance);
        float darkMatter = interaction.darkMatterDensity;
        float darkEnergy = computeDarkEnergy(interaction.distance);
        interactionSum += influence * exp(-alpha * interaction.distance) *
                         computePermeation(interaction.dimension) * darkMatter;
        totalDarkMatter += darkMatter * influence;
        totalDarkEnergy += darkEnergy * influence;
    }

    totalInfluence += interactionSum;
    float collapseValue = computeCollapse();

    // Write result to output buffer
    results[idx] = vec4(
        totalInfluence + collapseValue,           // observable
        max(0.0, totalInfluence - collapseValue), // potential
        totalDarkMatter,                          // darkMatter
        totalDarkEnergy                           // darkEnergy
    );
}
